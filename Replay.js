// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  var Deck, Replay, ReplayReader, fs, lzma, replayHeader;

  lzma = require('lzma');

  fs = require('fs');

  Deck = require('./Deck.js');

  replayHeader = (function() {
    class replayHeader {
      constructor() {
        this.id = 0;
        this.version = 0;
        this.flag = 0;
        this.seed = 0;
        this.dataSizeRaw = [];
        this.hash = 0;
        this.props = [];
      }

      getDataSize() {
        return this.dataSizeRaw[0] + this.dataSizeRaw[1] * 0x100 + this.dataSizeRaw[2] * 0x10000 + this.dataSizeRaw * 0x1000000;
      }

      getIsTag() {
        return this.flag & replayHeader.replayTagFlag > 0;
      }

      getIsCompressed() {
        return this.flag & replayHeader.replayCompressedFlag > 0;
      }

      getLzmaHeader() {
        var bytes;
        bytes = [].concat(this.props.slice(0, 5), this.dataSizeRaw, [0, 0, 0, 0]);
        return Buffer.from(bytes);
      }

    };

    replayHeader.replayCompressedFlag = 0x1;

    replayHeader.replayTagFlag = 0x2;

    replayHeader.replayDecodedFlag = 0x4;

    Object.defineProperty(replayHeader.prototype, 'dataSize', {
      get: replayHeader.getDataSize
    });

    Object.defineProperty(replayHeader.prototype, 'isTag', {
      get: replayHeader.getIsTag
    });

    Object.defineProperty(replayHeader.prototype, 'isCompressed', {
      get: replayHeader.getIsCompressed
    });

    return replayHeader;

  })();

  ReplayReader = class ReplayReader {
    constructor(buffer) {
      this.pointer = 0;
      this.buffer = buffer;
    }

    readByte() {
      var answer;
      answer = this.buffer.readUInt8(this.pointer);
      this.pointer += 1;
      return answer;
    }

    readByteArray(length) {
      var answer, i, j, ref;
      answer = [];
      for (i = j = 1, ref = length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        answer.push(this.readByte());
      }
      return answer;
    }

    readInt8() {
      var answer;
      answer = this.buffer.readInt8LE(this.pointer);
      this.pointer += 1;
      return answer;
    }

    readInt16() {
      var answer;
      answer = this.buffer.readInt16LE(this.pointer);
      this.pointer += 2;
      return answer;
    }

    readInt32() {
      var answer;
      answer = this.buffer.readInt32LE(this.pointer);
      this.pointer += 4;
      return answer;
    }

    readAll() {
      var answer;
      answer = this.buffer.slice(this.pointer);
      return answer;
    }

    readString(length) {
      var answer, full;
      full = this.buffer.slice(this.pointer, this.pointer + length).toString('utf-16le');
      answer = full.split("\u0000")[0];
      this.pointer += length;
      return answer;
    }

  };

  Replay = class Replay {
    constructor() {
      this.header = null;
      this.hostName = "";
      this.clientName = "";
      this.startLp = 0;
      this.startHand = 0;
      this.drawCount = 0;
      this.opt = 0;
      this.hostDeck = null;
      this.clientDeck = null;
    }

    static fromFile(filePath) {
      return Replay.fromBuffer(fs.readFileSync(filePath));
    }

    static fromBuffer(buffer) {
      var decompressed, header, lzmaBuffer, reader, replay;
      reader = new ReplayReader(buffer);
      header = Replay.readHeader(reader);
      lzmaBuffer = Buffer.concat([header.getLzmaHeader(), reader.readAll()]);
      if (header.isCompressed) {
        decompressed = lzmaBuffer;
      } else {
        decompressed = Buffer.from(lzma.decompress(lzmaBuffer));
      }
      reader = new ReplayReader(decompressed);
      replay = Replay.readReplay(header, reader);
      return replay;
    }

    static readHeader(reader) {
      var header;
      header = new replayHeader();
      header.id = reader.readInt32();
      header.version = reader.readInt32();
      header.flag = reader.readInt32();
      header.seed = reader.readInt32();
      header.dataSizeRaw = reader.readByteArray(4);
      header.hash = reader.readInt32();
      header.props = reader.readByteArray(8);
      return header;
    }

    static readReplay(header, reader) {
      var replay;
      replay = new Replay();
      replay.header = header;
      replay.hostName = reader.readString(40);
      replay.clientName = reader.readString(40);
      replay.startLp = reader.readInt32();
      replay.startHand = reader.readInt32();
      replay.drawCount = reader.readInt32();
      replay.opt = reader.readInt32();
      replay.hostDeck = Replay.readDeck(reader);
      replay.clientDeck = Replay.readDeck(reader);
      return replay;
    }

    static readDeck(reader) {
      var deck;
      deck = new Deck;
      deck.main = Replay.readDeckPack(reader);
      deck.ex = Replay.readDeckPack(reader);
      return deck;
    }

    static readDeckPack(reader) {
      var answer, i, j, length, ref;
      length = reader.readInt32();
      answer = [];
      for (i = j = 1, ref = length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        answer.push(reader.readInt32());
      }
      return answer;
    }

  };

  module.exports = Replay;

}).call(this);

//# sourceMappingURL=Replay.js.map
